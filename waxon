#!/usr/bin/env bash
# WaxOn — Interactive CLI: consistent, safe, and DAW-ready audio
# VERSION v1.4 — adds --attenuate-only mode to tame hot/clipped sources without boosting quiet takes
#
# Summary:
# - Measures integrated loudness first, then (optionally) applies ONLY negative gain toward target LUFS.
# - Optional auto declip if measured true-peak is ~0 dBTP.
# - True-peak-safe limiting with brief oversampling, then render to 24-bit WAV at source rate (or 44.1/48 kHz).
#
# Requirements: ffmpeg (and optionally osascript for macOS file picker / dialogs)

set -u          # no unset variables
set +e          # don't exit on errors; we handle per-file

# ---------------- Config (env-overridable) ----------------
VERSION="${VERSION:-v1.4}"
APP_TITLE="WaxOn ${VERSION} — DAW-ready Audio (Interactive)"

PROMPT="${PROMPT:-1}"                    # 1 = ask when no args (macOS file picker if available), 0 = args only
ATTENUATE_ONLY="${ATTENUATE_ONLY:-1}"    # 1 = never raise levels; only reduce hot sources, 0 = bidirectional normalize
LUFS_TARGET="${LUFS_TARGET:--25}"        # Integrated LUFS target reference (used for attenuation decision)
TP_CEILING_DBTP="${TP_CEILING_DBTP:--1.0}" # True-peak ceiling in dBTP
ATTACK_MS="${ATTACK_MS:-5}"              # limiter attack (ms)
RELEASE_MS="${RELEASE_MS:-50}"           # limiter release (ms)
HPF_HZ="${HPF_HZ:-20}"                   # high-pass to remove DC/rumble
DECLIP="${DECLIP:-auto}"                 # auto | on | off
OVERSAMPLE_LIMIT="${OVERSAMPLE_LIMIT:-1}"# 1 = upsample to 192k around limiter for intersample safety
OUTPUT_SR_MODE="${OUTPUT_SR_MODE:-keep}" # keep | 44100 | 48000
SAMPLE_FMT="${SAMPLE_FMT:-s24}"          # output sample format (s24 recommended)

# Log (macOS path; on Linux it still works under ~)
LOG="${LOG:-${HOME}/Library/Logs/waxon_${VERSION}.log}"
mkdir -p "$(dirname "$LOG")"
exec >>"$LOG" 2>&1
echo ""
echo "======== $(date '+%Y-%m-%d %H:%M:%S') — Start WaxOn ${VERSION} ========"
echo "Args: $*"
echo "Env: ATTENUATE_ONLY=${ATTENUATE_ONLY} TARGET=${LUFS_TARGET} TP=${TP_CEILING_DBTP} SR=${OUTPUT_SR_MODE}"

# ---------------- Helpers ----------------
die()  { echo "ERROR: $*" >&2; exit 1; }
info() { printf '%s\n' "$*"; }
warn() { printf 'WARN: %s\n' "$*" >&2; }

is_macos() { [ "$(uname)" = "Darwin" ]; }

mac_dialog() {
  # usage: mac_dialog "Title" "Message"
  if is_macos && command -v osascript >/dev/null 2>&1; then
    /usr/bin/osascript <<-APPLESCRIPT >/dev/null 2>&1
      tell application "System Events"
        display dialog "$(printf '%s' "$2" | sed 's/"/\\"/g')" with title "$(printf '%s' "$1" | sed 's/"/\\"/g')" buttons {"OK"} default button "OK" giving up after 1
      end tell
APPLESCRIPT
  fi
}

choose_files_macos() {
  # returns newline-delimited POSIX paths
  /usr/bin/osascript <<'APPLESCRIPT'
    set fList to choose file with multiple selections allowed
    set o to ""
    repeat with f in fList
      set o to o & POSIX path of f & linefeed
    end repeat
    return o
APPLESCRIPT
}

stem() {
  # strip extension: "dir/file.ext" -> "dir/file"
  local f="$1"
  echo "${f%.*}"
}

get_src_sr() {
  ffprobe -v error -select_streams a:0 -show_entries stream=sample_rate \
          -of default=noprint_wrappers=1:nokey=1 "$1" 2>/dev/null | head -n1
}

limit_linear_from_db() {
  # convert dBTP (negative) to linear amplitude for ffmpeg alimiter's `limit=`
  # uses awk's exp/log
  awk -v tp="$1" 'BEGIN{print exp((tp/20.0)*log(10))}'
}

# Parse a numeric field from loudnorm JSON
json_field() {
  # usage: json_field "$json" "measured_I"
  printf '%s\n' "$1" | awk -v key="\"$2\"" '
    match($0, "\"" $2 "\"[[:space:]]*:[[:space:]]*(-?[0-9.]+)", m) { print m[1]; found=1 }
    END { if (!found) print "" }'
}

measure_loudnorm_json() {
  # Emit loudnorm analysis JSON for a file
  local in="$1"
  ffmpeg -hide_banner -nostats -i "$in" \
    -af "loudnorm=I=${LUFS_TARGET}:TP=${TP_CEILING_DBTP}:LRA=11:print_format=json" \
    -f null - 2>&1 | sed -n '/^{/,/^}/p'
}

compute_gain_delta_db() {
  # delta = target - measured_I; if ATTENUATE_ONLY==1, clamp positive to 0
  local measured_I="$1" tgt="$2"
  awk -v mi="$measured_I" -v t="$tgt" -v att="$ATTENUATE_ONLY" '
    BEGIN{
      d = t - mi
      if (att == 1 && d > 0) d = 0   # only attenuate
      printf("%.6f", d)
    }'
}

need_declip_from_tp() {
  # return 1 if measured true-peak is at/above -0.1 dBTP
  local measured_tp="$1"
  awk -v tp="$measured_tp" 'BEGIN{print (tp > -0.1) ? 1 : 0}'
}

# ---------------- Usage ----------------
usage() {
cat <<'USAGE'
WaxOn — consistent, safe, and DAW-ready audio (v1.4)

Usage:
  waxon.sh [options] <audio files...>

Options (env var in parentheses):
  --attenuate-only / --no-attenuate-only   Enable/disable attenuation-only mode (ATTENUATE_ONLY=1)
  -t, --target <LUFS>                      Target LUFS reference, default -25 (LUFS_TARGET)
  --tp <dBTP>                              True-peak ceiling, default -1.0 (TP_CEILING_DBTP)
  --sr keep|44100|48000                    Output sample rate, default keep (OUTPUT_SR_MODE)
  --declip auto|on|off                     Declip mode, default auto (DECLIP)
  --no-prompt                              Disable interactive file picker if no args (PROMPT=0)
  -h, --help                               Show this help

Examples:
  waxon.sh --attenuate-only -t -25 --tp -1.0 *.wav
  LUFS_TARGET=-23 ATTENUATE_ONLY=0 ./waxon.sh take1.wav take2.wav
USAGE
}

# ---------------- Arg parsing ----------------
FILES=()
while [ $# -gt 0 ]; do
  case "$1" in
    --attenuate-only) ATTENUATE_ONLY=1 ;;
    --no-attenuate-only) ATTENUATE_ONLY=0 ;;
    -t|--target) shift; LUFS_TARGET="${1:?missing LUFS target}" ;;
    --tp) shift; TP_CEILING_DBTP="${1:?missing TP ceiling}" ;;
    --sr) shift; OUTPUT_SR_MODE="${1:?keep|44100|48000}" ;;
    --declip) shift; DECLIP="${1:?auto|on|off}" ;;
    --no-prompt) PROMPT=0 ;;
    -h|--help) usage; exit 0 ;;
    --) shift; while [ $# -gt 0 ]; do FILES+=("$1"); shift; done; break ;;
    -*)
      warn "Unknown option: $1"
      usage; exit 1
      ;;
    *)
      FILES+=("$1")
      ;;
  esac
  shift
done

if [ ${#FILES[@]} -eq 0 ] && [ "$PROMPT" = "1" ] && is_macos && command -v osascript >/dev/null 2>&1; then
  PICKED="$(choose_files_macos || true)"
  if [ -n "$PICKED" ]; then
    # read into array
    while IFS= read -r line; do
      [ -n "$line" ] && FILES+=("$line")
    done <<<"$PICKED"
  fi
fi

[ ${#FILES[@]} -eq 0 ] && { usage; exit 1; }

# ---------------- Processing ----------------
LIMIT_LINEAR="$(limit_linear_from_db "$TP_CEILING_DBTP")"
[ -z "$LIMIT_LINEAR" ] && LIMIT_LINEAR="0.891"  # fallback for -1.0 dBTP

TOTAL=0
OK=0
FAIL=0

mac_dialog "$APP_TITLE" "Starting processing of ${#FILES[@]} file(s). Attenuate-only: ${ATTENUATE_ONLY}; Target: ${LUFS_TARGET} LUFS; TP ceiling: ${TP_CEILING_DBTP} dBTP."

for inpath in "${FILES[@]}"; do
  TOTAL=$((TOTAL+1))
  if [ ! -f "$inpath" ]; then
    warn "Skip (not a file): $inpath"
    FAIL=$((FAIL+1))
    continue
  fi

  info "-----"
  info "File: $inpath"

  # 1) Measure loudness / TP
  LJSON="$(measure_loudnorm_json "$inpath")"
  if [ -z "$LJSON" ]; then
    warn "Could not measure loudness for: $inpath"
    FAIL=$((FAIL+1))
    continue
  fi
  MEAS_I="$(json_field "$LJSON" measured_I)"
  MEAS_TP="$(json_field "$LJSON" measured_TP)"
  [ -z "$MEAS_I" ] && MEAS_I="0"
  [ -z "$MEAS_TP" ] && MEAS_TP="-99"

  DELTA_DB="$(compute_gain_delta_db "$MEAS_I" "$LUFS_TARGET")"

  # 2) Decide declip and SR
  DO_DECLIP=0
  case "$DECLIP" in
    on) DO_DECLIP=1 ;;
    off) DO_DECLIP=0 ;;
    auto) DO_DECLIP="$(need_declip_from_tp "$MEAS_TP")" ;;
    *) warn "Invalid DECLIP='$DECLIP', using auto"; DO_DECLIP="$(need_declip_from_tp "$MEAS_TP")" ;;
  esac

  SRC_SR="$(get_src_sr "$inpath")"
  case "$OUTPUT_SR_MODE" in
    keep) OUT_SR="$SRC_SR" ;;
    44100|48000) OUT_SR="$OUTPUT_SR_MODE" ;;
    *) warn "Unknown OUTPUT_SR_MODE='${OUTPUT_SR_MODE}', keeping ${SRC_SR}"; OUT_SR="$SRC_SR" ;;
  esac
  [ -z "$OUT_SR" ] && OUT_SR=48000

  # 3) Build filtergraph
  #    highpass -> (optional adeclip) -> (optional oversample) -> volume (delta) -> limiter -> downsample
  AF="highpass=f=${HPF_HZ}"
  if [ "$DO_DECLIP" = "1" ]; then
    AF="${AF},adeclip=threshold=10:arorder=8"
  fi
  if [ "$OVERSAMPLE_LIMIT" = "1" ]; then
    AF="${AF},aresample=192000"
  fi
  AF="${AF},volume=${DELTA_DB}dB"
  AF="${AF},alimiter=limit=${LIMIT_LINEAR}:attack=${ATTACK_MS}:release=${RELEASE_MS}"
  if [ "$OVERSAMPLE_LIMIT" = "1" ]; then
    AF="${AF},aresample=out_sample_rate=${OUT_SR}"
  else
    AF="${AF},aresample=${OUT_SR}"
  fi

  # 4) Output path
  base="$(stem "$inpath")"
  tag="wax"
  [ "$ATTENUATE_ONLY" = "1" ] && tag="wax-attonly"
  outpath="${base}-${tag}.wav"

  # 5) Run ffmpeg
  info "Measure I: ${MEAS_I} LUFS; TP: ${MEAS_TP} dBTP; Gain Δ: ${DELTA_DB} dB; Declip: ${DO_DECLIP}; Out SR: ${OUT_SR} Hz"
  info "ffmpeg -i \"$inpath\" -af \"$AF\" -sample_fmt ${SAMPLE_FMT} \"$outpath\""

  ffmpeg -hide_banner -y -i "$inpath" -af "$AF" -sample_fmt "$SAMPLE_FMT" "$outpath"
  rc=$?

  if [ $rc -eq 0 ] && [ -f "$outpath" ]; then
    OK=$((OK+1))
    info "OK → $outpath"
  else
    FAIL=$((FAIL+1))
    warn "Failed on: $inpath"
    continue
  fi

done

# ---------------- Summary ----------------
SUMMARY=$(
  cat <<EOF
Files processed: ${TOTAL}
Successful:      ${OK}
Failed:          ${FAIL}

Settings:
  Attenuate-only: ${ATTENUATE_ONLY}
  Target LUFS:    ${LUFS_TARGET}
  TP ceiling:     ${TP_CEILING_DBTP} dBTP (limit=${LIMIT_LINEAR})
  HPF:            ${HPF_HZ} Hz
  Declip:         ${DECLIP}
  Oversample:     ${OVERSAMPLE_LIMIT}
  Output SR mode: ${OUTPUT_SR_MODE}
  Sample format:  ${SAMPLE_FMT}

Tip:
  Attenuate-only means Δ = min(0, targetLUFS − measured_I), so quiet tracks are never boosted.
  The limiter with brief oversampling helps catch inter-sample peaks near the true-peak ceiling.
EOF
)
printf '\n%s\n' "$SUMMARY"
mac_dialog "$APP_TITLE" "$SUMMARY"
