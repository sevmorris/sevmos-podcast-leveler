#!/usr/bin/env bash
# WaxOn — Limiter-Only CLI (aligns with Automator droplet)
# v1.0.3
# Pipeline: DC block → (optional) declip → hygiene HPF → mono ch0 → resample → true-peak-safe limiter → dither → 24-bit WAV
# No loudness normalization. No makeup gain.
#
# Naming: <stem>-<44k|48k><SUFFIX_BASE>-<LIMIT_TAG>.wav  e.g. my_take-48kwaxon--1dB.wav

set -u
set +e
unset POSIXLY_CORRECT >/dev/null 2>&1 || true

LC_ALL="${LC_ALL:-en_US.UTF-8}"
LANG="${LANG:-en_US.UTF-8}"
export LC_ALL LANG

PATH="/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:$PATH"; export PATH

VERSION="v1.0.3"
APP_NAME="WaxOn"
APP_TITLE="${APP_NAME} ${VERSION} — Limiter-Only CLI"

# Defaults (env overridable)
SAMPLE_RATE="${SAMPLE_RATE:-48000}"           # 44100 | 48000
LIMIT_DB="${LIMIT_DB:--1.0}"                  # limiter ceiling (dBFS)
ATTACK_MS="${ATTACK_MS:-5}"
RELEASE_MS="${RELEASE_MS:-50}"
TRUEPEAK="${TRUEPEAK:-1}"                     # 1|0
TP_OVERSAMPLE="${TP_OVERSAMPLE:-4}"           # 4|8
DITHER="${DITHER:-1}"
CLIP_REPAIR="${CLIP_REPAIR:-auto}"            # auto|1|0
CLIP_THRESHOLD="${CLIP_THRESHOLD:-1}"         # min clipped-sample count to enable auto declip
DC_BLOCK_HZ="${DC_BLOCK_HZ:-20}"              # gentle HPF at start
SUFFIX_BASE="${SUFFIX_BASE:-waxon}"
PROMPT="${PROMPT:-1}"                         # 1=prompt; 0=no prompt
LOG="${LOG:-${HOME}/Library/Logs/waxon_cli_${VERSION}.log}"

FFMPEG_BIN="${FFMPEG_BIN:-$(command -v ffmpeg || true)}"
FFPROBE_BIN="${FFPROBE_BIN:-$(command -v ffprobe || true)}"

# --- Logging ---
mkdir -p "$(dirname "$LOG")" 2>/dev/null || true
exec >>"$LOG" 2>&1
echo "======== $(date '+%Y-%m-%d %H:%M:%S') — Start run ========"
echo "App: ${APP_TITLE}"
echo "Args: $*"
command -v ffmpeg  && ffmpeg -version  | head -n1
command -v ffprobe && ffprobe -version | head -n1

# --- Help ---
usage() {
cat <<USAGE
${APP_TITLE}

Usage: waxon [options] file1 [file2 ...]

Options:
  -s, --samplerate <Hz>    44100 | 48000 (default: ${SAMPLE_RATE})
  -l, --limit-db <dBFS>    Limiter ceiling (default: ${LIMIT_DB})
      --attack <ms>        Limiter attack (default: ${ATTACK_MS})
      --release <ms>       Limiter release (default: ${RELEASE_MS})
      --truepeak <0|1>     True-peak oversampling on/off (default: ${TRUEPEAK})
      --tp-oversample <N>  Oversampling factor 4 or 8 (default: ${TP_OVERSAMPLE})
      --dither <0|1>       Final-stage TPDF HP dither (default: ${DITHER})
      --clip-repair <m>    auto | 1 (force) | 0 (off) (default: ${CLIP_REPAIR})
      --clip-threshold <n> Min clipped-sample count to enable declip (default: ${CLIP_THRESHOLD})
      --dc-block-hz <Hz>   DC/infra-DC HP corner (default: ${DC_BLOCK_HZ})
      --outdir <dir>       Output directory (default: alongside source; fallback Music/WaxOn, Desktop)
      --suffix-base <tag>  Suffix token (default: ${SUFFIX_BASE})
      --no-prompt          Non-interactive (PROMPT=0)
  -h, --help               Show this help

Environment variables mirror flags (e.g., LIMIT_DB, SAMPLE_RATE, TRUEPEAK, TP_OVERSAMPLE, DITHER, PROMPT, LOG).
USAGE
}

# --- Parse args ---
OUTDIR=""
NO_PROMPT=0
args=()
while [ $# -gt 0 ]; do
  case "$1" in
    -h|--help) usage; exit 0 ;;
    -s|--samplerate) SAMPLE_RATE="$2"; shift 2 ;;
    -l|--limit-db) LIMIT_DB="$2"; shift 2 ;;
    --attack) ATTACK_MS="$2"; shift 2 ;;
    --release) RELEASE_MS="$2"; shift 2 ;;
    --truepeak) TRUEPEAK="$2"; shift 2 ;;
    --tp-oversample) TP_OVERSAMPLE="$2"; shift 2 ;;
    --dither) DITHER="$2"; shift 2 ;;
    --clip-repair) CLIP_REPAIR="$2"; shift 2 ;;
    --clip-threshold) CLIP_THRESHOLD="$2"; shift 2 ;;
    --dc-block-hz) DC_BLOCK_HZ="$2"; shift 2 ;;
    --outdir) OUTDIR="$2"; shift 2 ;;
    --suffix-base) SUFFIX_BASE="$2"; shift 2 ;;
    --no-prompt) NO_PROMPT=1; PROMPT=0; shift ;;
    --) shift; break ;;
    -*)
      echo "Unknown option: $1" >&2
      usage; exit 1 ;;
    *) args+=("$1"); shift ;;
  esac
done
set -- "${args[@]}"

[ $# -ge 1 ] || { usage; exit 0; }
[ -n "$FFMPEG_BIN" ] || { echo "FFmpeg not found. Install with: brew install ffmpeg"; exit 1; }
[ -n "$FFPROBE_BIN" ] || { echo "ffprobe not found. Reinstall FFmpeg."; exit 1; }

# --- ALWAYS-PROMPT MODE (like droplet) ---
if [ "$PROMPT" = "1" ] && [ "$NO_PROMPT" -eq 0 ]; then
  # Sample rate prompt (default = current SAMPLE_RATE)
  def_sr_idx=2; def_sr_label="48 kHz"
  if [ "$SAMPLE_RATE" = "44100" ]; then def_sr_idx=1; def_sr_label="44.1 kHz"; fi
  echo "Select output sample rate:"
  echo "  [1] 44.1 kHz"
  echo "  [2] 48 kHz"
  read -r -p "Choice [${def_sr_idx} = ${def_sr_label}]: " choice_sr
  case "${choice_sr:-$def_sr_idx}" in
    1) SAMPLE_RATE=44100 ;;
    2) SAMPLE_RATE=48000 ;;
    *) SAMPLE_RATE=48000 ;;
  esac

  # Limiter ceiling prompt (default = current LIMIT_DB)
  # Map default to index 1..6
  case "$LIMIT_DB" in
    -1.0) def_idx=1 ;;
    -2.0) def_idx=2 ;;
    -3.0) def_idx=3 ;;
    -4.0) def_idx=4 ;;
    -5.0) def_idx=5 ;;
    -6.0) def_idx=6 ;;
    *) def_idx=1 ; LIMIT_DB="-1.0" ;;
  esac
  echo "Select limiter ceiling (dBFS):"
  echo "  [1] -1 dB"
  echo "  [2] -2 dB"
  echo "  [3] -3 dB"
  echo "  [4] -4 dB"
  echo "  [5] -5 dB"
  echo "  [6] -6 dB"
  read -r -p "Choice [${def_idx} = ${LIMIT_DB} dBFS]: " choice_lim
  case "${choice_lim:-$def_idx}" in
    1) LIMIT_DB="-1.0" ;;
    2) LIMIT_DB="-2.0" ;;
    3) LIMIT_DB="-3.0" ;;
    4) LIMIT_DB="-4.0" ;;
    5) LIMIT_DB="-5.0" ;;
    6) LIMIT_DB="-6.0" ;;
    *) LIMIT_DB="-1.0" ;;
  esac
fi

# --- Helpers ---
to_amp() { awk -v db="$1" 'BEGIN{print exp((db/20.0)*log(10))}'; }
strip_trailing_zero() { printf "%s" "$1" | sed 's/\(\.[0-9]*[1-9]\)0\+$//; s/\.0$//'; }

limit_amp="$(to_amp "$LIMIT_DB")"
LIMIT_DB_CLEAN="$(strip_trailing_zero "$LIMIT_DB")"
LIMIT_TAG="${LIMIT_DB_CLEAN}dB"

# --- Clipped-sample detector ---
detect_clipped_samples() {
  local in_file="$1"
  "$FFMPEG_BIN" -nostdin -hide_banner -v error -i "$in_file" \
    -af "astats=metadata=1:reset=0" -f null - 2>&1 \
  | awk 'BEGIN{sum=0} /clipped[[:space:]]+samples/i{for(i=1;i<=NF;i++)if($i~/^[0-9]+$/)sum+=$i} END{if(sum=="")sum=0; print sum}'
}

# --- Process ---
success_n=0
fail_n=0

for in_path in "$@"; do
  echo "--- Processing: $in_path"
  if [ ! -f "$in_path" ]; then echo "Skip (not a file): $in_path"; continue; fi

  dir="$(cd "$(dirname "$in_path")" && pwd -P)"
  base="$(basename "$in_path")"
  stem="${base%.*}"

  # Output directory
  outdir="$dir"
  if [ -n "$OUTDIR" ]; then outdir="$OUTDIR"; fi
  if [ ! -w "$outdir" ]; then
    outdir="${HOME}/Music/WaxOn"; mkdir -p "$outdir" || outdir="${HOME}/Desktop"
  fi

  # Rate tag
  case "$SAMPLE_RATE" in
    44100) RATE_TAG="44k" ;;
    48000) RATE_TAG="48k" ;;
    *) echo "Invalid sample rate: $SAMPLE_RATE"; fail_n=$((fail_n+1)); continue ;;
  esac

  out_path="${outdir}/${stem}-${RATE_TAG}${SUFFIX_BASE}-${LIMIT_TAG}.wav"
  tmp_path="${outdir}/.${stem}-${RATE_TAG}${SUFFIX_BASE}-${LIMIT_TAG}.wav.tmp"

  # Auto declip decision
  apply_declip="0"
  case "$CLIP_REPAIR" in
    1) apply_declip="1" ;;
    0) apply_declip="0" ;;
    *)
      clips="$(detect_clipped_samples "$in_path")"
      if [ "$clips" -ge "$CLIP_THRESHOLD" ]; then apply_declip="1"; fi
      ;;
  esac

  # Build AF chains
  step1_af="highpass=f=${DC_BLOCK_HZ}"
  [ "$apply_declip" = "1" ] && step1_af="${step1_af},adeclip"
  step1_af="${step1_af},highpass=f=20,pan=1c|c0=c0,aresample=${SAMPLE_RATE}:resampler=soxr"

  lim="alimiter=limit=${limit_amp}:attack=${ATTACK_MS}:release=${RELEASE_MS}:level=disabled"

  if [ "$TRUEPEAK" = "1" ]; then
    oversample=$(( SAMPLE_RATE * TP_OVERSAMPLE ))
    if [ "$DITHER" = "1" ]; then
      final_af="${step1_af},aresample=${oversample}:resampler=soxr,${lim},aresample=${SAMPLE_RATE}:resampler=soxr:dither_method=triangular_hp"
    else
      final_af="${step1_af},aresample=${oversample}:resampler=soxr,${lim},aresample=${SAMPLE_RATE}:resampler=soxr"
    fi
  else
    if [ "$DITHER" = "1" ]; then
      final_af="${step1_af},${lim},aresample=${SAMPLE_RATE}:resampler=soxr:dither_method=triangular_hp"
    else
      final_af="${step1_af},${lim},aresample=${SAMPLE_RATE}:resampler=soxr"
    fi
  fi

  # Render to hidden temp
  if "$FFMPEG_BIN" -nostdin -hide_banner -loglevel error -y \
       -i "$in_path" -af "$final_af" \
       -c:a pcm_s24le -ar ${SAMPLE_RATE} -ac 1 \
       -f wav "$tmp_path"
  then
    # Reveal atomically
    if mv -f "$tmp_path" "$out_path" 2>/dev/null; then : ; else
      cp -f "$tmp_path" "$out_path" && rm -f "$tmp_path" 2>/dev/null || true
    fi

    if [ -s "$out_path" ]; then
      echo "✅ Done -> $out_path"; success_n=$((success_n+1))
    else
      echo "❌ Post-reveal check failed: $out_path"; fail_n=$((fail_n+1))
    fi
  else
    echo "❌ Render failed for: $in_path"; fail_n=$((fail_n+1))
    rm -f "$tmp_path" 2>/dev/null || true
  fi
done

echo "Summary: ${success_n} ok, ${fail_n} failed"
echo "======== $(date '+%Y-%m-%d %H:%M:%S') — Done ========"
exit 0
