#!/usr/bin/env bash
# WaxOn — Dialogue/VO Preprocessing (reader-friendly CLI)
# DC block → (optional) clip-repair → normalize to −25 LUFS → TP ceiling −1 dBTP
# Output: 24-bit mono WAV @ 44.1k or 48k. Atomic writes. TTY prompts. Clean console.

set -u
IFS=$'\n\t'
PATH="/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:${PATH}"

# ---------- Defaults (env/flags can override) ----------
VERSION="${VERSION:-v1.3}"
PROMPT="${PROMPT:-1}"                 # 1 interactive, 0 flags/env
TARGET_I="${TARGET_I:--25}"           # LUFS target for editing
TARGET_TP="${TARGET_TP:--1.0}"        # true-peak safety
SAMPLE_RATE="${SAMPLE_RATE:-44100}"   # 44100 | 48000
CLIP_REPAIR="${CLIP_REPAIR:-auto}"    # auto|on|off
DITHER="${DITHER:-1}"                  # 1 on, 0 off (to 24-bit)
OUTDIR="${OUTDIR:-}"                  # empty = in-place
QUIET="${QUIET:-0}"                   # 1 = less chat
VERBOSE="${VERBOSE:-0}"               # 1 = more chat
LOG="${LOG:-${HOME}/Library/Logs/waxon_cli.log}"

TTY="/dev/tty"; [[ -w "$TTY" ]] || TTY="/dev/stdout"

# ---------- UI helpers ----------
_supports_color() { command -v tput >/dev/null && [ -t 1 ] && tput setaf 1 >/dev/null 2>&1; }
if _supports_color; then
  BOLD="$(tput bold)"; DIM="$(tput dim)"; NC="$(tput sgr0)"
  FG_OK="$(tput setaf 2)"; FG_WARN="$(tput setaf 3)"; FG_ERR="$(tput setaf 1)"; FG_INFO="$(tput setaf 6)"
else
  BOLD=""; DIM=""; NC=""; FG_OK=""; FG_WARN=""; FG_ERR=""; FG_INFO=""
fi
OK="✅"; WARN="⚠️ "; ERR="❌"; DOT="•"

log() { printf '%s\n' "$*" >>"$LOG"; }
say() { [[ "$QUIET" = "1" ]] && return 0; printf '%s\n' "$*" >"$TTY"; log "$*"; }
info() { printf '%s\n' "${FG_INFO}$*${NC}" >"$TTY"; log "$*"; }
good() { printf '%s\n' "${FG_OK}$*${NC}" >"$TTY"; log "$*"; }
warn() { printf '%s\n' "${FG_WARN}$*${NC}" >"$TTY"; log "WARN: $*"; }
err() {  printf '%s\n' "${FG_ERR}$*${NC}" >"$TTY" ; log "ERR:  $*"; }
die() { err "$*"; exit 1; }
need() { command -v "$1" >/dev/null 2>&1 || die "Missing dependency: $1"; }

mkdir -p "$(dirname "$LOG")" 2>/dev/null || true
log ""
log "======== $(date '+%Y-%m-%d %H:%M:%S') — WaxOn start ========"
log "Args: $*"
log "ENV: VER=$VERSION PROMPT=$PROMPT TARGET_I=$TARGET_I TP=$TARGET_TP SR=$SAMPLE_RATE CLIP_REPAIR=$CLIP_REPAIR DITHER=$DITHER OUTDIR='${OUTDIR}' QUIET=$QUIET VERBOSE=$VERBOSE"
command -v ffmpeg >/dev/null 2>&1 && ffmpeg -version | head -n1 >>"$LOG" 2>&1

# ---------- Atomic writer (preserve extension; hint muxer) ----------
# atomic_write <final_path> wav -- <ffmpeg args before output>
atomic_write() {
  local final="$1"; shift
  local fmt="$1"; shift
  [[ "$1" == "--" ]] && shift || true
  local dir base stem ext tmp
  dir="$(dirname "$final")"; base="$(basename "$final")"; ext="${final##*.}"; stem="${base%.*}"
  tmp="${dir}/.${stem}.tmp.$$.$ext"
  mkdir -p "$dir" 2>/dev/null || true
  ffmpeg -hide_banner -nostdin -y -f "$fmt" "$@" "$tmp" >>"$LOG" 2>&1
  local rc=$?
  [[ $rc -eq 0 ]] && mv -f "$tmp" "$final"
  return $rc
}

# ---------- Simple prompt helpers (TTY-safe) ----------
_prompt() { printf '%s' "$1" >"$TTY"; IFS= read -r REPLY <"$TTY"; }
choose_sr() {
  printf '%s\n' "Sample rate:
  1) 44100 Hz (default)
  2) 48000 Hz" >"$TTY"
  _prompt "Enter 1-2 (default 1): "
  case "${REPLY:-1}" in 1) SAMPLE_RATE="44100";; 2) SAMPLE_RATE="48000";; *) SAMPLE_RATE="44100";; esac
}

# ---------- Flags ----------
show_help() {
  cat <<HLP >"$TTY"
${BOLD}WaxOn${NC} — Dialogue/VO Pre-Mix Prep (v${VERSION})
Usage: waxon [options] <files...>

Options:
  --no-prompt            Non-interactive (use env/flags)
  -s, --samplerate <hz>  44100 | 48000   (default 44100)
  --clip-repair <mode>   auto|on|off     (default auto)
  --dither <0|1>         to 24-bit       (default 1)
  -o, --outdir <dir>     output directory (default: alongside source)
  -q, --quiet            terse output
  -v, --verbose          more detail; echo ffmpeg lines to console
  -h, --help             this text

ENV you can set:
  TARGET_I=-25   TARGET_TP=-1.0   PROMPT=0|1   OUTDIR=/path   LOG=...

Examples:
  waxon *.wav
  PROMPT=0 TARGET_I=-25 -- clip-repair auto, 48k:
    waxon --no-prompt -s 48000 ~/takes/*.wav
HLP
}

PROMPT_SET=0
while [[ $# -gt 0 ]]; do
  case "$1" in
    --no-prompt) PROMPT=0; PROMPT_SET=1; shift ;;
    -s|--samplerate) SAMPLE_RATE="$2"; shift 2 ;;
    --clip-repair) CLIP_REPAIR="$2"; shift 2 ;;
    --dither) DITHER="$2"; shift 2 ;;
    -o|--outdir) OUTDIR="$2"; shift 2 ;;
    -q|--quiet) QUIET=1; shift ;;
    -v|--verbose) VERBOSE=1; shift ;;
    -h|--help) show_help; exit 0 ;;
    --) shift; break ;;
    -*) die "Unknown option: $1" ;;
    *) break ;;
  esac
done
[[ $# -lt 1 ]] && { err "No input files. Try: waxon -h"; exit 1; }

# ---------- Validate options ----------
need ffmpeg
case "$SAMPLE_RATE" in 44100|48000) ;; *) die "SAMPLE_RATE must be 44100 or 48000";; esac
case "$CLIP_REPAIR" in auto|on|off) ;; *) die "CLIP_REPAIR must be auto|on|off";; esac
case "$DITHER" in 0|1) ;; *) die "DITHER must be 0 or 1";; esac

# ---------- Interactive (optional) ----------
if [[ "$PROMPT" = "1" && "$PROMPT_SET" = "0" ]]; then
  choose_sr
fi

# ---------- One-time header ----------
say "${BOLD}WaxOn${NC} ${DIM}${VERSION}${NC}  ${DOT}  Target: ${BOLD}${TARGET_I} LUFS${NC}  ${DOT}  TP ceiling: ${BOLD}${TARGET_TP} dBTP${NC}  ${DOT}  SR: ${BOLD}${SAMPLE_RATE} Hz${NC}"
say "${DIM}Tip:${NC} Console output is clean; full details are in ${LOG}"

# ---------- Build processing chain ----------
# DC block (very gentle highpass)
DCF="highpass=f=20,adeclick=0"       # adeclick=0 is a no-op placeholder if you don’t want RX-like repair
# Clip repair policy
case "$CLIP_REPAIR" in
  on)   REPAIR="aresample=resampler=soxr,adeclip" ;;     # FFmpeg's adeclip
  auto) REPAIR="adeclip" ;;                              # fast, lightweight attempt
  off)  REPAIR="anullsink"; REPAIR=""; ;;                # nothing
esac
# LUFS normalize (editing target) with linear=true = transparent
NORM="loudnorm=I=${TARGET_I}:TP=${TARGET_TP}:LRA=11:linear=true:print_format=summary"
# Limit true peaks via truepeak in loudnorm path; (loudnorm TP handles TP ceiling)
# Downmix mono channel 0
MONO="pan=mono|c0=c0"

# Dither to 24-bit if requested (ffmpeg handles quantization on encode)
PCM_CODEC="pcm_s24le"
[[ "$DITHER" = "0" ]] && PCM_CODEC="pcm_s24le"   # keep same codec; dithering minimal control in ffmpeg

# ---------- Core per-file processing ----------
ok=0; fail=0
process_one() {
  local in="$1"
  [[ -f "$in" ]] || { warn "Skip (missing): $in"; return 1; }

  local dir base stem outdir out
  dir="$(cd "$(dirname "$in")" && pwd -P)"
  base="$(basename "$in")"
  stem="${base%.*}"
  outdir="${OUTDIR:-$dir}"
  out="${outdir}/${stem}-prep${TARGET_I}LUFS.wav"

  # Compose filtergraph
  local chain=""
  [[ -n "$DCF" ]]   && chain+="${DCF},"
  [[ -n "$REPAIR" ]]&& chain+="${REPAIR},"
  chain+="${NORM},${MONO},aresample=${SAMPLE_RATE}:resampler=soxr"

  # Show one concise line
  printf "%s  %-38s  →  %s\n" "$DOT" "${base}" "${stem}-prep${TARGET_I}LUFS.wav" >"$TTY"

  # Run (atomic)
  mkdir -p "$outdir" 2>/dev/null || true
  local tmp="${outdir}/.${stem}.tmp.$$ .wav"; tmp="${tmp// /}"  # ensure hidden tmp; keep .wav extension
  if [[ "$VERBOSE" = "1" ]]; then
    ffmpeg -hide_banner -nostdin -y -i "$in" -map 0:a:0 -vn \
      -filter:a "$chain" -c:a "$PCM_CODEC" -ar "$SAMPLE_RATE" -dn "$tmp" 2>>"$LOG" | tee -a "$LOG"
  else
    ffmpeg -hide_banner -nostdin -y -i "$in" -map 0:a:0 -vn \
      -filter:a "$chain" -c:a "$PCM_CODEC" -ar "$SAMPLE_RATE" -dn "$tmp" >>"$LOG" 2>&1
  fi
  local rc=$?
  if [[ $rc -ne 0 ]]; then
    err "${ERR} ${base}  (ffmpeg failed; see log)"
    rm -f "$tmp"
    return 1
  fi

  mv -f "$tmp" "$out"
  good "${OK} ${base}"
  return 0
}

for f in "$@"; do
  process_one "$f" && ok=$((ok+1)) || fail=$((fail+1))
done

# ---------- Summary ----------
echo "" >"$TTY"
if [[ $fail -eq 0 ]]; then
  say "${BOLD}Done.${NC}  ${OK} Files: ${ok} ok"
else
  say "${BOLD}Done with issues.${NC}  ${OK} ${ok} ok   ${ERR} ${fail} failed"
  say "See ${LOG} for details."
fi

exit $([[ $fail -gt 0 ]] && echo 2 || echo 0)
