#!/usr/bin/env bash
# WaxOn (CLI) — Consistent, safe, and DAW-ready audio
# VERSION v1.4
# 44.1/48 kHz • 24-bit WAV mono (Left or Right) + brickwall peak limiter (no makeup gain)
# DC blocker at chain start (gentle high-pass, default 20 Hz)
# Hidden dotfile temp is used until completion, then atomically revealed.

set -u
set +e
unset POSIXLY_CORRECT >/dev/null 2>&1 || true

LC_ALL="${LC_ALL:-en_US.UTF-8}"
LANG="${LANG:-en_US.UTF-8}"
export LC_ALL LANG

PATH="/opt/homebrew/bin:/usr/local/bin:/usr/local/sbin:/usr/bin:/bin:/usr/sbin:/sbin":$PATH; export PATH

# ---- Defaults (override via flags or env) ----
VERSION="v1.4"
APP_NAME="WaxOn"
TAGLINE="Consistent, safe, and DAW-ready audio."
APP_TITLE="${APP_NAME} ${VERSION} — ${TAGLINE}"

PROMPT="${PROMPT:-1}"                  # 1 = interactive; 0 = non-interactive
PROMPT_LIMIT="${PROMPT_LIMIT:-1}"      # 1 = ask limiter ceiling if interactive
SAMPLE_RATE="${SAMPLE_RATE:-0}"        # 44100 or 48000; 0 = prompt if interactive
CHANNEL="${CHANNEL:-left}"             # left|right|0|1
LIMIT_DB="${LIMIT_DB:--1.0}"           # -1.0 .. -6.0
ATTACK_MS="${ATTACK_MS:-5}"
RELEASE_MS="${RELEASE_MS:-50}"
TRUEPEAK="${TRUEPEAK:-1}"              # 1 = enable oversampled limiter path
TP_OVERSAMPLE="${TP_OVERSAMPLE:-4}"    # 2, 4, 8 ... (must be integer >=2)
DITHER="${DITHER:-1}"                  # 1 = triangular HP dither on final downsample
DC_BLOCK_HZ="${DC_BLOCK_HZ:-20}"       # high-pass cutoff
OUTDIR="${OUTDIR:-}"
LOG="${LOG:-$HOME/Library/Logs/waxon_cli_${VERSION}.log}"

# ---- Help ----
print_help() { cat <<'EOS'
WaxOn (CLI) — limiter-only preprocessing
Usage:
  waxon [options] <audio files...>

Options:
  --no-prompt               Run non-interactively (PROMPT=0).
  -s, --samplerate <Hz>     44100 or 48000.
  -c, --channel <ch>        left | right | 0 | 1  (default: left).
  -l, --limit <dB>          Limiter ceiling in dBFS (e.g., -1, -2, -3 ...).
  --attack <ms>             Limiter attack (default 5).
  --release <ms>            Limiter release (default 50).
  --truepeak <0|1>          Enable oversampled true-peak style limiting (default 1).
  --oversample <N>          Oversample factor for true-peak path (default 4).
  --dither <0|1>            Apply TPDF-HP dither on final render (default 1).
  --dc <Hz>                 DC blocker HPF cutoff (default 20).
  -o, --outdir <dir>        Destination directory (default: alongside source, fallback ~/Music/WaxOn).
  --log <path>              Log path (default: ~/Library/Logs/waxon_cli_v1.4.log)
  -h, --help                Show help.

Environment overrides are supported for all options (e.g., SAMPLE_RATE, CHANNEL, LIMIT_DB, TRUEPEAK, etc.).
EOS
}

# ---- Parse args ----
args=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    --no-prompt) PROMPT=0; shift;;
    -s|--samplerate) SAMPLE_RATE="$2"; shift 2;;
    -c|--channel) CHANNEL="$2"; shift 2;;
    -l|--limit) LIMIT_DB="$2"; shift 2;;
    --attack) ATTACK_MS="$2"; shift 2;;
    --release) RELEASE_MS="$2"; shift 2;;
    --truepeak) TRUEPEAK="$2"; shift 2;;
    --oversample) TP_OVERSAMPLE="$2"; shift 2;;
    --dither) DITHER="$2"; shift 2;;
    --dc) DC_BLOCK_HZ="$2"; shift 2;;
    -o|--outdir) OUTDIR="$2"; shift 2;;
    --log) LOG="$2"; shift 2;;
    -h|--help) print_help; exit 0;;
    --) shift; break;;
    -*)
      echo "Unknown option: $1" >&2
      print_help; exit 2;;
    *)
      args+=("$1"); shift;;
  esac
done

# Remaining non-option args
if [[ ${#args[@]} -eq 0 ]]; then
  print_help
  exit 1
fi

# ---- Logging ----
mkdir -p "$(dirname "$LOG")" 2>/dev/null || true
{
  echo "======== $(date '+%Y-%m-%d %H:%M:%S') — Start run ========"
  echo "App: $APP_TITLE"
  echo "Args: ${args[*]}"
  echo "PATH=$PATH"
  command -v ffmpeg && ffmpeg -version | head -n1
  command -v ffprobe && ffprobe -version | head -n1
} >>"$LOG" 2>&1

FFMPEG_BIN="$(command -v ffmpeg || true)"
FFPROBE_BIN="$(command -v ffprobe || true)"
if [[ -z "$FFMPEG_BIN" || -z "$FFPROBE_BIN" ]]; then
  echo "FFmpeg/ffprobe not found. Install with: brew install ffmpeg" | tee -a "$LOG" >&2
  exit 1
fi

# ---- Helpers ----
to_amp() { awk -v db="$1" 'BEGIN{print exp((db/20.0)*log(10))}'; }
strip_trailing_zero() { printf "%s" "$1" | sed 's/\(\.[0-9]*[1-9]\)0\+$//; s/\.0$//'; }

# interactive prompts (if PROMPT=1)
if [[ "$PROMPT" -eq 1 ]]; then
  # sample rate
  if [[ "$SAMPLE_RATE" -eq 0 ]]; then
    echo "Select output sample rate: [1] 44.1 kHz  [2] 48 kHz"
    read -r -p "> " choice_sr
    case "$choice_sr" in
      1|"44.1"|"44100") SAMPLE_RATE=44100 ;;
      2|"48"|"48000")   SAMPLE_RATE=48000 ;;
      *) SAMPLE_RATE=44100 ;;
    esac
  fi
  # channel
  case "$CHANNEL" in
    left|0|"") CHANNEL="left" ;;
    right|1)   CHANNEL="right" ;;
    *) echo "Channel? [1] Left  [2] Right"; read -r -p "> " choice_ch
       case "$choice_ch" in 2) CHANNEL="right";; *) CHANNEL="left";; esac ;;
  esac
  # limiter selection (optional toggle)
  if [[ "$PROMPT_LIMIT" -eq 1 ]]; then
    echo "Select limiter ceiling (dBFS): [1]-1  [2]-2  [3]-3  [4]-4  [5]-5  [6]-6"
    read -r -p "> " choice_lim
    case "$choice_lim" in
      2) LIMIT_DB="-2.0";;
      3) LIMIT_DB="-3.0";;
      4) LIMIT_DB="-4.0";;
      5) LIMIT_DB="-5.0";;
      6) LIMIT_DB="-6.0";;
      *) LIMIT_DB="-1.0";;
    esac
  fi
fi

# sanitize and derive tags
if [[ "$SAMPLE_RATE" != "44100" && "$SAMPLE_RATE" != "48000" ]]; then
  echo "Invalid SAMPLE_RATE '$SAMPLE_RATE' (use 44100 or 48000)" | tee -a "$LOG" >&2
  exit 2
fi
case "$CHANNEL" in
  left|0)  PAN_MONO='pan=1c|c0=c0'; MONO_LABEL="Left channel";;
  right|1) PAN_MONO='pan=1c|c0=c1'; MONO_LABEL="Right channel";;
  *) echo "Invalid CHANNEL '$CHANNEL' (use left/right/0/1)" | tee -a "$LOG" >&2; exit 2;;
esac

limit_amp="$(to_amp "$LIMIT_DB")"
LIMIT_DB_CLEAN="$(strip_trailing_zero "$LIMIT_DB")"
LIMIT_TAG="${LIMIT_DB_CLEAN}dB"

if [[ "$SAMPLE_RATE" -eq 44100 ]]; then RATE_TAG="44k"; else RATE_TAG="48k"; fi
SUFFIX="${RATE_TAG}waxon"

echo "Ready:
  • Sample rate: $SAMPLE_RATE Hz
  • Mono channel: $MONO_LABEL
  • Limiter: ${LIMIT_DB_CLEAN} dBFS (attack ${ATTACK_MS} ms / release ${RELEASE_MS} ms)
  • DC block: ${DC_BLOCK_HZ} Hz
" | tee -a "$LOG"

# working dir
WORKDIR="$(mktemp -d -t waxon_cli_${RATE_TAG}_XXXXXX)"
cleanup() { rm -rf "$WORKDIR"; }
trap 'cleanup' HUP INT TERM EXIT

success_n=0
fail_n=0

for in_path in "${args[@]}"; do
  echo "--- Processing: $in_path" | tee -a "$LOG"
  if [[ ! -f "$in_path" ]]; then
    echo "Skip (not a file): $in_path" | tee -a "$LOG"
    continue
  fi

  dir="$(dirname "$in_path")"
  base="$(basename "$in_path")"
  stem="${base%.*}"

  dest="$OUTDIR"
  if [[ -z "$dest" ]]; then
    dest="$dir"
    if [[ ! -w "$dest" ]]; then
      dest="$HOME/Music/WaxOn"; mkdir -p "$dest" 2>/dev/null || dest="$HOME/Desktop"
    fi
  else
    mkdir -p "$dest" 2>/dev/null || true
  fi

  out_path="${dest}/${stem}-${SUFFIX}-${LIMIT_TAG}.wav"
  hidden_tmp="${dest}/.${stem}-${SUFFIX}-${LIMIT_TAG}.wav.tmp"
  mid_path="${WORKDIR}/${stem}_${RATE_TAG}24_mono.wav"

  # Step 1: DC block → mono (selected channel) → resample → 24-bit mono WAV
  step1_af="highpass=f=${DC_BLOCK_HZ},${PAN_MONO},aresample=${SAMPLE_RATE}:resampler=soxr"
  echo "Step 1 -> $mid_path (dc_block=${DC_BLOCK_HZ} Hz; mono=${MONO_LABEL})" >>"$LOG"
  if ! "$FFMPEG_BIN" -nostdin -hide_banner -loglevel error -y         -i "$in_path" -af "$step1_af"         -c:a pcm_s24le -ar $SAMPLE_RATE -ac 1 "$mid_path" >>"$LOG" 2>&1; then
    echo "Step 1 failed: $in_path" | tee -a "$LOG"
    ((fail_n++)); continue
  fi

  # Step 2: limiter-only chain with optional oversampled true-peak path
  lim="alimiter=limit=${limit_amp}:attack=${ATTACK_MS}:release=${RELEASE_MS}:level=disabled"
  if [[ "$TRUEPEAK" == "1" ]]; then
    oversample=$(( SAMPLE_RATE * TP_OVERSAMPLE ))
    if [[ "$DITHER" == "1" ]]; then
      af="aresample=${oversample}:resampler=soxr,${lim},aresample=${SAMPLE_RATE}:resampler=soxr:dither_method=triangular_hp"
    else
      af="aresample=${oversample}:resampler=soxr,${lim},aresample=${SAMPLE_RATE}:resampler=soxr"
    fi
  else
    if [[ "$DITHER" == "1" ]]; then
      af="${lim},aresample=${SAMPLE_RATE}:resampler=soxr:dither_method=triangular_hp"
    else
      af="${lim},aresample=${SAMPLE_RATE}:resampler=soxr"
    fi
  fi

  rm -f "$hidden_tmp" 2>/dev/null || true
  echo "Render -> $hidden_tmp" >>"$LOG"
  if "$FFMPEG_BIN" -nostdin -hide_banner -loglevel error -y        -i "$mid_path" -af "$af"        -c:a pcm_s24le -ar $SAMPLE_RATE -ac 1 -f wav "$hidden_tmp" >>"$LOG" 2>&1; then
    if [[ ! -s "$hidden_tmp" ]]; then
      echo "❌ Render produced no data" | tee -a "$LOG"
      ((fail_n++)); continue
    fi
    mv -f "$hidden_tmp" "$out_path" 2>>"$LOG" || (cp -f "$hidden_tmp" "$out_path" && rm -f "$hidden_tmp") || true
    if [[ -s "$out_path" ]]; then
      echo "✅ Done -> $out_path" | tee -a "$LOG"
      ((success_n++))
    else
      echo "❌ Output write failed" | tee -a "$LOG"
      ((fail_n++))
    fi
  else
    echo "❌ Render failed" | tee -a "$LOG"
    ((fail_n++))
  fi
done

echo "======== $(date '+%Y-%m-%d %H:%M:%S') — Done (ok=$success_n, fail=$fail_n) ========" >>"$LOG"

echo ""
echo "✅ Processing complete"
echo "• $success_n success$( [[ $success_n -ne 1 ]] && echo 'es' )$( [[ $fail_n -gt 0 ]] && echo " • $fail_n failed" )"
echo "• Output: 24-bit mono ($MONO_LABEL) @ $SAMPLE_RATE Hz"
echo "• Limiter ceiling: ${LIMIT_DB_CLEAN} dBFS (no makeup gain)"
echo "• DC block: ${DC_BLOCK_HZ} Hz"
echo "Log: $LOG"
